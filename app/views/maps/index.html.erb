<style type="text/css">
  html, body {
    height: 100%; /* Ensures the body and HTML elements fill the entire viewport */
    margin: 0; /* Removes default margins */
    overflow: hidden; /* Prevents scrolling if content overflows */
  }

  #actions button {
    padding: 10px 20px;
    font-size: 16px;
    background-color: #007bff;
    color: white;
    border: none;
    cursor: pointer;
  }

  #actions button:hover {
    background-color: #0056b3; /* Changes button color on hover */
  }

  #actions {
    position: fixed; /* Ensures the actions panel stays in one place */
    bottom: 20px; /* Adjusts the distance from the bottom of the viewport */
    right: 20px; /* Adjusts the distance from the right side of the viewport */
    z-index: 1000; /* Ensures it is above other elements */
    background-color: rgba(255, 255, 255, 0.9); /* Adds a semi-transparent background */
    padding: 10px; /* Adds some inner spacing */
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Gives a subtle shadow for better visibility */
    border-radius: 8px; /* Rounds the corners */
    border: 1px solid #ccc; /* Optional: Adds a light border */
  }
</style>

<div id="map" style="height: 100%; width: 100%; position: relative;"></div>
<div id="actions" style="height: 200px; margin: 0; padding: 0;">
  <button id="displayBoundsButton">Display Bounds</button>

  <button id="displayMarkerClusters">Display Marker Clusters</button>

  <button id="displayMarkers">✅ Display Markers</button>
  <br />
  <br />
  <button id="clearMarkers"> ❌ Clear all Markers</button>
</div>
<script>
  function debounce(func, wait) {
    let timeout;
    return function(...args) {
      const context = this;
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(context, args), wait);
    };
  }

  function markerDOM(name, address, latitude, longitude) {
    return `
      <div>
        <p><b>${name}</b></p>
        <p><b>${address}</b></p>
        <p><b>${latitude},${longitude}</b></p>
      </div>
    `
  }
</script>

<script>
  const map = L.map("map").setView([-33.907635, 150.921796], 11);
  let $mapMarkers = [];
  const markerClusters = L.markerClusterGroup();
  let markers = [];
  const addedMarkerIds = new Set();

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
  }).addTo(map);

  function loadPlaces() {
    const center = map.getCenter();
    const radius = 5000; // meters

    const params = new URLSearchParams({
      center_lat: center.lat,
      center_lng: center.lng,
      radius: radius
    });

    fetch(`/places?${params}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    })
    .then(response => response.json())
    .then(data => {
      // Create a new marker cluster group
      $mapMarkers = data;
    })
    .catch(error => console.error("Error loading places:", error));
  };

  const debouncedLoadPlaces = debounce(loadPlaces, 500);

  function showMarkerClusters() {
    $mapMarkers.forEach(place => {
      const { latitude, longitude, name, addresses } = place;
      const mainAddress = [addresses[0]['freeform'], addresses[0]['postcode'], addresses[0]['region']].join(', ');

      const markerId = `${latitude},${longitude}`; // prevent dup
      if (!addedMarkerIds.has(markerId)) {
        const marker = L.marker([latitude, longitude])
                        .bindPopup(markerDOM(name, mainAddress, latitude, longitude));
        markerClusters.addLayer(marker);
        addedMarkerIds.add(markerId);
      };
    });

    map.addLayer(markerClusters);
  }

  function showMarkers() {
    $mapMarkers.forEach(place => {
      const { latitude, longitude, name, addresses } = place;
      const mainAddress = [addresses[0]['freeform'], addresses[0]['postcode'], addresses[0]['region']].join(', ');

      const markerId = `${latitude},${longitude}`; // prevent dup
      if (!addedMarkerIds.has(markerId)) {
        const marker = L.marker([latitude, longitude])
          .bindPopup(markerDOM(name, mainAddress, latitude, longitude))
          .openPopup();

        marker.addTo(map);
        markers.push(marker);
        addedMarkerIds.add(markerId);
      };
    });
  }

  function clearAllMarkers() {
    markerClusters.clearLayers();
    markers.forEach(marker => map.removeLayer(marker));
    addedMarkerIds.clear();
  }

  map.on('moveend', debouncedLoadPlaces);
  map.on('zoomend', debouncedLoadPlaces);

  document.getElementById('displayBoundsButton').addEventListener('click', function() {
    displayBounds(exampleBounds);
  });

  document.getElementById('displayMarkers').addEventListener('click', function() {
    showMarkers();
  });

  document.getElementById('displayMarkerClusters').addEventListener('click', function() {
    showMarkerClusters();
  });

  document.getElementById('clearMarkers').addEventListener('click', function() {
    clearAllMarkers();
  });

  // Function to display the bounds on the map
  function displayBounds(bounds) {
    // Fit the map view to the given bounds
    map.fitBounds(bounds);
  }
</script>
